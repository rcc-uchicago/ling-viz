<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Sankey Diagram</title>
<style>

html {
    width:100%;
    height:100%;
}

body {
    width: 100%;
    height: 100%;
    margin: 0;
}

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

.sel {
  stroke-opacity: .5;
}

</style>
<body>
<p id="chart" />

<script src="d3.js"></script>
<script src="sankey.js"></script>
<script src="graphutils.js"></script>
<script>


d3.json("json/english-brown.json", function(json) {
    /* If using "english-brown.json", try "oh" (fewest contexts) */

    var wordparam = getParameterByName("word");
    var words = wordparam ? wordparam.split(',') : ["oh"];

    var data = getSankeyData(words, json.contexts);


    //var height = calcHeight(data.nodes, 10);


    var margin = {top: 1, right: 1, bottom: 6, left: 1},
        width = document.body.clientWidth - margin.left - margin.right
        height = document.body.clientHeight - margin.top - margin.bottom;  


    var formatNumber = d3.format(",.0f"),
        format = function(d) { return formatNumber(d); },
        color = d3.scale.category20();

    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height",height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
   


    var sankey = d3.sankey()
        .nodeWidth(15)
        .nodePadding(10)
        .size([width, height]);

    var path = sankey.link();

    sankey
      .nodes(data.nodes)
      .links(data.links)
      .layout(32);


    //data.nodes.forEach(function(d) {
    //    d.y = d.y * (height / fake_height);
    //});
    
   
  var link = svg.append("g").selectAll(".link")
      .data(data.links)
    .enter().append("path")
      .attr("class", "link")
      .attr("d", path)
      .style("stroke-width", function(d) { return Math.max(1, d.dy); })
      .sort(function(a, b) { return b.dy - a.dy; });

  link.append("title")
      .text(function(d) { return d.source.name + " â†’ " + d.target.name + "\n" + format(d.value); });

  var node = svg.append("g").selectAll(".node")
      .data(data.nodes)
    .enter().append("g")
      .attr("class", "node")
      .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; }) /* x and y are added by sankey.layout() */
    .call(d3.behavior.drag()
      .origin(function(d) { return d; })
      .on("dragstart", function() { this.parentNode.appendChild(this); })
      .on("drag", dragmove));

  node.append("rect")
      .attr("height", function(d) { return d.dy; })
      .attr("width", sankey.nodeWidth())
      .style("fill", function(d) { return d.color = color(d.name.replace(/ .*/, "")); })
      .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
    .append("title")
      .text(function(d) { return d.name + "\n" + format(d.value); });

 
  node.append("text")
      .attr("x", -6)
      .attr("y", function(d) { return d.dy / 2; })
      .attr("dy", ".35em")
      .attr("text-anchor", "end")
      .attr("transform", null)
      .text(function(d) { return d.name; })
    .filter(function(d) { return d.x < width / 2; })
      .attr("x", 6 + sankey.nodeWidth())
      .attr("text-anchor", "start");

    /* Fix negative heights - ideally, ultimately the Sankey Y-layout should be fixed.

    function getPosition(node) {
        var s = node.getAttribute("transform");
        var r = s.match(/(-?[0-9]+)/g)
        return r;
    }

    for (var i = 0; i < 5; i++) {
        var nd = node.filter(function(d) { return d.pos == i });
        var E = d3.extent(nd[0], function(d) { return +getPosition(d)[1] });
        var m = E[0], M = E[1];
        if (m < 0 || M > height) {
            console.log(E);
            var bottom = Math.abs(m);
            var space = bottom + M;
            nd.each(function(n, i) {
                var xy = getPosition(this);
                var y = (+xy[1] + bottom) * (height / space);
                //console.log("bottom: " + bottom + " height " + height + " space " + space)
                //console.log("Pos " + i + " old ht " + xy[1] + " new " + Math.floor(y))
                //throw new Error("ghel");
                this.setAttribute("transform", "translate(" + xy[0] + "," + Math.floor(y) + ")");
            });
        }
    } 
*/

  function dragmove(d) {
    d3.select(this).attr("transform", "translate(" + d.x + "," + (d.y = Math.max(0, Math.min(height - d.dy, d3.event.y))) + ")");
    sankey.relayout();
    link.attr("d", path);
  }

  
  /* Path hightlighting */
    
    /* Given a link, highlight the entire path. */
    function highlightPath(lk) {
        lk.classed("sel", true);
        var edge = lk.datum();
        link.each(function (d) {
            if (edge.prev.indexOf(d) >= 0 || edge.next.indexOf(d) >= 0) {
                d3.select(this).classed("sel", true);
            }
        });
    }
    
    link.on("mouseover",
        function() {
            var lk = d3.select(d3.event.target);
            highlightPath(lk);          
        });
    link.on("mouseout", function() { link.classed("sel", false); });
    
     
    
    node.on("mouseover",
        function() {
            var nd = d3.select(d3.event.target).datum();
            link.each(function (d) {
                if (d.source == nd || d.target == nd) {
                    highlightPath(d3.select(this));
                }
            });
        });
    node.on("mouseout", function() { link.classed("sel", false); });
       
});

function calcHeight(nodes, nodepadding) {
   
    /*
    var nodesByBreadth = d3.nest()
        .key(function(d) { return d.pos; })
        .sortKeys(d3.ascending)
        .entries(nodes)
        .map(function(d) { return d.values; });

     height = max (over columns) of (nodePadding * (sum(i, v_i))) ) */
    //var ht = d3.max(nodesByBreadth, function(nodes) { return nodepadding * d3.sum(nodes, function(d) { return d.value } ); }); 
  
    var ht = nodepadding * nodes.length;

    return ht;
}


</script>
