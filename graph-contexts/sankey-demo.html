<!DOCTYPE html>
<html>
<meta charset="utf-8">
<title>Sankey Diagram</title>
<style>

html {
    width:100%;
    height:100%;
}

body {
    width: 100%;
    height: 100%;
    margin: 0;
}

.node rect {
  cursor: move;
  fill-opacity: .9;
  shape-rendering: crispEdges;
}

.node text {
  pointer-events: none;
  text-shadow: 0 1px 0 #fff;
}

.link {
  fill: none;
  stroke: #000;
  stroke-opacity: .2;
}

.sel {
  stroke-opacity: .5;
}

.menu {
    background: lightgrey;
    position: absolute;
    top: 0px;
    left: -500px;
    width: 200px;
    font: 10px sans-serif;

}

.here {
    position:absolute;
    top: 0px;
    background: lightgrey;
}

input[type="number"] {
   width: 30px;
}

</style>
<body>

<div class="here">
    <svg height="30" width="20">
    </svg>
    <div class="menu">
        <input type="checkbox" class="attr" id="usevalues" checked>Node thickness depends on value<br>
        <input type="checkbox" class="attr" id="usecolors" checked>Use custom color scheme<br>
        <input type="checkbox" id="uselabels" checked>Display labels of nodes<br>
        <input type="number" id="nodewidth" class="attr" min="0" max="100" value="15">Node width<br>
        <input type="number" id="nodepadding" class="attr" min="0" max="100" value="10">Node padding<br>
        <input type="checkbox" id="skinnyedges">Skinny edges <br>
        <input type="checkbox" id="customlayout" class="attr" checked>Use custom layout function <br>
        <input type="text" id="addword"> <br>
        <ul id="wordlist">
        </ul>
    </div>
</div>

<p id="chart" />

<script src="d3.js"></script>
<script src="sankey.js"></script>
<script src="graphutils.js"></script>
<script>

var menu = d3.select(".menu");
d3.select(".here")
    .on("mouseenter", menuin)
    .on("mouseleave", menuout);
function menuin() {
    menu
        .transition()
        .style("left", "0px");
}
function menuout() {
    menu
        .transition()
        .style("left", "-500px");
}

d3.json("json/english-brown.json", function(json) {
    /* If using "english-brown.json", try "oh" (fewest contexts) */

    var wordparam = getParameterByName("word");
    var words = wordparam ? wordparam.split(',') : ["oh"];
  
    DrawEverything(json, words);

});


function ischecked(s) { return d3.select('#' + s).node().checked };
function getvalue(s) { return d3.select('#' + s).node().value; };


function DrawEverything(json, words) {

    var data = {} //getSankeyData(json.words, json.contexts);

    var margin = {top: 1, right: 1, bottom: 6, left: 1},
        width = document.body.clientWidth - margin.left - margin.right
        height = document.body.clientHeight - margin.top - margin.bottom;  
    var color = d3.scale.category20();

    var svg = d3.select("#chart").append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height",height + margin.top + margin.bottom)
        .append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
   
    var sankey = d3.sankey()
        .size([width, fake_height])
        .displayHeight(height)


    var link = svg.append("g").selectAll(".link");
    var node = svg.append("g").selectAll(".node");

    var fake_height = 0;


    /* Menu items */

    function cbfunc(f1, f2) {
        return function () { this.checked ? f1() : f2() }
    }
    function lsfunc(n) {
        return function() {
            link.transition().style("stroke-width", n);
        }
    }


    
    d3.selectAll(".attr")
        .on("change", function() { if (! d3.select(".node").empty()) updateSVG() });
    
    d3.select("#uselabels")
        .on("change", function() {
            node.select("text").attr("visibility", this.checked ? "visible" : "hidden");        
         });

    d3.select("#skinnyedges")
        .on("change", cbfunc(lsfunc(1), lsfunc(function(d) { return Math.max(1, d.dy); })));
   
    d3.select("#addword")
        .on("change", function() {
            var w = d3.event.target.value;
             words.push(w);
             d3.select("#wordlist")
                .append("li").html("<a href='#'>" + w + "</a>")
                .select("a").on("click", removeWord);
             
             data = getSankeyData(words, json.contexts);
             updateSVG(data.nodes.sort(), data.links.sort());
        });   
    function removeWord() {
        var li = this.parentNode;
        var w = this.innerHTML;
        words.remove(w);
        data = getSankeyData(words, json.contexts);
        d3.select(li).remove();
        updateSVG(data.nodes.sort(), data.links.sort());
    }

    d3.select("#wordlist")
        .selectAll("li")
        .data(words)
        .enter()
        .append("li")
        .append("a")
        .attr("href", "#")
        .html(function(d) { return d; })
        .on("click", removeWord);

    if (words.length) {
        data = getSankeyData(words, json.contexts);
        updateSVG(data.nodes.sort(), data.links.sort());
    }

    function updateSVG(nodes, links) {
        

        var nodeWidth = getvalue("nodewidth");
        var useValues = ischecked("usevalues");
        var nodePadding = getvalue("nodepadding");
        var useColors = ischecked("usecolors");
        var skinnyEdges = ischecked("skinnyedges");
        var customLayout = ischecked("customlayout");
        var useLabels = ischecked("uselabels");

        if (nodes && links) {
            sankey.nodes(nodes);
            sankey.links(links);
            fake_height = calcHeight(nodes, nodePadding);
            sankey
                .size([width, fake_height])
                .displayHeight(height);
        }

        sankey
            .nodeWidth(nodeWidth)
            .nodePadding(nodePadding)
            .useValues(useValues)
            .customLayout(customLayout);
        sankey
            .layout(32);

        var path = sankey.link();

        if (useColors)
            applyColorScheme(data.nodes);
        else {
            data.nodes.forEach(function(d) {
                d.color = color(d.name.replace(/ .*/, ""))
            });
        }


        /* New values */
        if (nodes && links) {
            
            link = link.data(links, function(d) { return d.id; });
            link
                .enter().append("path")
                    .attr("class", "link")
                    .attr("d", path)
                    .style("stroke-width", skinnyEdges ? 1 : function(d) { return Math.max(1, d.dy); })
                    .on("mouseover", highlightlink)
                    .on("mouseout", unhighlight);
            link.append("title")
                .text(function(d) { return d.source.name + " â†’ " + d.target.name + "\n" + d.value; });
        /* remove unneeded */
            link.exit().remove();
            //link.sort(function(a, b) { return b.dy - a.dy; });
 
        /* Create new values */
            node = node.data(nodes, function(d) { return d.id; });
            node
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + d.x + "," + d.ht + ")"; }) 
                .call(d3.behavior.drag()
                .origin(function(d) { return d; })
                .on("dragstart", function() { this.parentNode.appendChild(this); })
                .on("drag", dragmove))
                .on("mouseover", highlightnode)
                .on("mouseout", unhighlight)

                .append("rect")
                .attr("height", function(d) { return d.dy; })
                .attr("width", sankey.nodeWidth())
                .style("fill", function(d) { return d.color; })
                .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
                .append("title")
                .text(function(d) { return d.name + "\n" + d.value; })
        
            node.select("text").remove();
            node.append("text")
                    .attr("x", -6)
                    .attr("y", function(d) { return d.dy / 2; })
                    .attr("dy", ".35em")
                    .attr("text-anchor", "end")
                    .attr("transform", null)
                    .text(function(d) { return d.name; })
                    .filter(function(d) { return d.x < width / 2; })
                    .attr("x", 6 + sankey.nodeWidth())
                    .attr("text-anchor", "start")
                    .attr("visibility", useLabels ? "visible" : "hidden");
            
            /* Remove old */
            node.exit().remove();

        }


        /* Update old values */
        link
            .transition()
            .attr("d", path)
            .style("stroke-width", skinnyEdges ? 1 : function(d) { return Math.max(1, d.dy); });

        if (nodes && links) {
            node.selectAll("rect").data(nodes, function(d) { return d.id; });
            node.selectAll("text").data(nodes, function(d) { return d.id; });
        }

        node
            .transition()
            .attr("transform", function(d) { return "translate(" + d.x + "," + d.ht + ")"; }) 

        node.selectAll("rect")
            .transition()
            .attr("height", function(d) { return d.dy; })
            .attr("width", sankey.nodeWidth())
            .style("fill", function(d) { return d.color; })
            .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })

        if (!(nodes && links) && useLabels) {
            node.selectAll("text")
                .transition()
                .attr("y", function(d) { return d.dy / 2; })
                .attr("dy", ".35em")
                .attr("x", 6 + sankey.nodeWidth())
        }
    
        function dragmove(d) {
            d.ht += d3.event.dy;
            d.y = d.ht * (fake_height / height);
            d3.select(this).attr("transform", "translate(" + d.x + "," + d.ht + ")");
            sankey.relayout();
            link.attr("d", path);
        }

   
   }

 
    /* Path highlighting */
    
    /* Given a link, highlight the entire path. */
    function highlightpath(lk) {
        lk.classed("sel", true);
        var edge = lk.datum();
        link.each(function (d) {
            if (edge.prev.indexOf(d) >= 0 || edge.next.indexOf(d) >= 0) {
                d3.select(this).classed("sel", true);
            }
        });
    }
   
    function highlightlink() {
        var lk = d3.select(d3.event.target);
        highlightpath(lk); 
    }

    function unhighlight() { link.classed("sel", false); };

    function highlightnode() {
        var nd = d3.select(d3.event.target).datum();
        link.each(function (d) {
            if (d.source == nd || d.target == nd) {
                highlightpath(d3.select(this));
            }
        });
    }    

}

function calcHeight(nodes, nodepadding) {
    var ht = nodepadding * nodes.length;
    return ht;
}



function applyColorScheme(nodes) {
    var nodesByPos = {}
    for(var i = -2; i <= 2; i++)
        nodesByPos[i] = nodes.filter(function(n) { return n.pos == i; });

    function getmask(n) {
        var mask = []
        for (var i = -2; i <= 2; i++) {
            nodesByPos[i].forEach(function (m) {
                if(m.name == n.name)
                    mask.push(i);
            });
        }
        return mask;
    }
    applyColorScheme.colors =
        { "-2": "pink",
          "-1": "red",
          "0": "black",
          "1": "blue",
          "2": "lightblue",
          "-2,-1": "orange",
          "1,2": "green" };
   
    nodes.forEach(function(n) {
        var mask = getmask(n);
        n.color = applyColorScheme.colors[mask] || "grey";
    });
    

}


</script>
